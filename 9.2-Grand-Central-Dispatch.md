この章では、iOSにおけるマルチスレッドの手法であるGCD(Grand Central Dispatch)の使い方と、使う上での注意点について解説します

この章では、次のAppleのドキュメントを参考に作成しています。
https://developer.apple.com/jp/devcenter/ios/library/documentation/ConcurrencyProgrammingGuide.pdf


## iOSにおけるマルチスレッド
iOSにおける並列処理の手法にはいくつかの手法があります。

- NSThread : スレッドを立てて、そのスレッドの中で処理を行う。スレッドの管理やキューイングなどの管理はアプリケーションが行う
- GCD (dispatch_xxx) : スレッドの管理などをOSレベルで実装したもの。処理をしたいタスクをBlockで渡す。渡されたタスクはキューに挿入されて逐次実行される。C言語による実装
  - NSOperation : GCDと同じように振る舞う、Objective-Cのオブジェクト。

この中で、GCDがよく利用されています。NSThreadだとスレッドの処理などを自前で書かないといけないのでコードが冗長になってしまい大変です。

そこで今回は、よく用いられるiOSにおける並列処理実行技術、GCDについて解説を進めて行きます。

## スマートフォンアプリにおけるマルチスレッドの必要性


# dispatch queue

dispatch queueはGCDの中でも中核をなす仕組みです。その仕組みについて、上記Appleのドキュメントには次のように記載されています。

> ディスパッチキューは、アプリケーションのタスク群を非同期かつ並列に実行する手段として、容易
に利用できます。タスクとは、アプリケーションが実行するべき、何らかの処理を表す言葉です。何
らかの計算をする、データ構造を生成/修正する、ファイルからデータを読み込んで加工する、など
といった処理がタスクに当たります。タスクの定義は、そのためのコードを関数またはブロックオブ
ジェクトの形で記述し、ディスパッチキューに追加することにより行います。
ディスパッチキューは、オブジェクトに似た構造を持っており、登録されたタスクを管理する働きが
あります。ディスパッチキューはいずれも、先入れ先出し方式のデータ構造です。すなわち、タスク
はキューに追加した順に実行されることになります。


図にするとこんなイメージです。
![https://raw.github.com/mixi-inc/iOSTraining/master/Doc/Images/9.2/gcd_1.png](https://raw.github.com/mixi-inc/iOSTraining/master/Doc/Images/9.2/gcd_1.png)

ポイントとしては、

- タスク群を並列実行する手段
- タスクはブロックオブジェクトの形で記述する
- dispatch queue はキューとしてタスクを管理しFIFOで実行する

というところが挙げられると思います。ディスパッチキューを利用するにあたって必要なことはリファレンスに次のように述べられています

> タスクを非同期に実行する技術のひとつとして、Grand Central Dispatch（GCD）というものがありま
す。通常はアプリケーション中に記述するスレッド管理用のコードを、システムレベルで実装したも
のです。開発者がしなければならないのは、実行したいタスクを定義し、適切なディスパッチキュー
に追加することだけです。するとGCDは、必要なスレッドを生成し、そこでタスクを実行するよう適
切にスケジューリングします。

スレッドの生成や管理はシステムがやってくれるので、開発を進めて行く上で必要なことは、
- 実行したいタスクを定義する
- 適切なディスパッチキューに追加する

の2点になります。次項以降で、キューへの追加の方法と適切なキューの選び方を説明します。
またあわせて、GCDで利用できる他のAPIについても解説します.


## dispatch queue への追加
dispatch queue への追加には次の関数を使います。

| 関数名 | 説明 |
| ---- | ---- |
| `void dispatch_async(dispatch_queue_t queue, dispatch_block_t block) ` | blockで定義された処理をqueueに追加する。タスクの処理は非同期で実行され、タスクの実行完了を待たずに制御は進む |
| `void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block) ` |  blockで定義された処理をqueueに追加する。タスクの処理は同期的に実行され、タスクの実行が完了するまで制御は止まる |


それぞれの関数の引数は、処理をキューイングしたいキューを指定するqueueと、処理したい内容を記述したブロックblockです。
実際に用いてみると次のようになります

```
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{

    NSLog(@"Hello GCD!");

});
```

この例では、queueとして優先度がバックグラウンドのglobal queueを取得しています(後述します）。また処理内容は、"Hello GCD!"と出力するものを指定しました。

これを適当な箇所で実行すると、コンソールに"Hello GCD!"と表示されます


## dispatch queue で用いることの出来るキューの種類

dispatch queueで用いられるキューにはいくつかの種類があります。まず大きく分類してみましょう。

| キューの種類 | 説明 |
| ---------- | ----|
| 直列 serial dispatch queue | タスクを同時に一つずつ追加された順に実行する仕組み。あるタスクの実行が終わると次のタスクの実行を行う。タスクは他のキューと独立したスレッド上で動作。 |
| 並列 concurrent dispatch queue | 複数のタスクを同時に実行する。実行の順番はキューに追加した順番になるが、終了のタイミングの順序は保証されない。同時に実行するタスクの数はシステムの状況に応じて変化する。アプリケーションが所有するglobal queueとアプリケーション内部で生成するqueueを持つことができる。キューには優先度をつけることができる |
| メインディスパッチキュー | アプリケーションのどこからでも利用することの出来るシリアルキューで、アプリケーションのメインスレッド上で実行される。UIの更新などはこのキューを用いて行う必要があります |


serial dispatch queue と concurrent dispatch queue の違いは以下のようになります

![https://raw.github.com/mixi-inc/iOSTraining/master/Doc/Images/9.2/gcd_2.png](https://raw.github.com/mixi-inc/iOSTraining/master/Doc/Images/9.2/gcd_2.png)

serial queue は同時に一つしか実行されないので、一つ前のタスクの結果によって次のタスクの処理が変わる場合に用いられることが多いです。例えばファイルやDBへのアクセスなどがそれに該当します。mixiの公式クライアントアプリではアクセストークンの更新などにも用いられています。

一方でconcurrent queue は同時にいくつものタスクを並列に実行することができます。処理一つ一つが前回のタスクに依存しないとき、他のスレッドとデータを共有しないときなどで幅広く用いることができます。例えばダウンローダなどはこの仕組みを利用することができると思います。

### キューの生成と取得

これらのキューはどのようにして取得することができるのでしょうか、その点について次に説明します。

#### グローバルなコンカレントキューの取得
各アプリケーションには初めから優先度の異なる４つのグローバルキューが生成されており、アプリケーションのどこからでも取得できるようになっています。
次の関数で取得することができます。

```
dispatch_queue_t dispatch_get_global_queue(long priority, unsigned long flags);
```

priorityには次のうち一つを指定してください。

| キー名 | 優先度 |
| ----- | ----- |
| DISPATCH_QUEUE_PRIORITY_HIGH | 優先度高 |
| DISPATCH_QUEUE_PRIORITY_DEFAULT | 優先度中 |
| DISPATCH_QUEUE_PRIORITY_LOW | 優先度低 |
| DISPATCH_QUEUE_PRIORITY_BACKGROUND | 優先度バックグラウンド |

flagsには今のところ0を指定しておいてください(今のところは利用されていませんが、後々利用される可能性があるため)

#### メインキューの取得
メインキューを取得するには次の関数を利用します。
```
dispatch_queue_t dispatch_get_main_queue(void);
```

#### キューの生成
キューはグローバルなキューを取得するだけでなく、アプリケーションの一部のみで利用されるキューをアプリケーション内部で生成して利用することも出来ます。直列、並列なキューのどちらも生成することができます。

生成には次の関数を使います。

```
dispatch_queue_t dispatch_queue_create( const char *label, dispatch_queue_attr_t attr);
```

labelには、キューのラベルをつけます。システム中で用いることはありませんが、デバッグを行った時のスタックトレースなどに出力されます。Appleのリファレンスによると、逆DNS記法でつけることが推奨されています(例:com.example.myqueue)

dispatch_queue_attr_tでは、キューのタイプが直列か並列を指定します。(iOS5以降)
直列の場合は、DISPATCH_QUEUE_SERIALを並列の場合はDISPATCH_QUEUE_CONCURRENTを指定します。


### GCD用例


## GCDのその他のAPI







